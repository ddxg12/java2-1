# 최한솔 학번 : 202130235


## 5월 3일 강의 
### 7단원. 컬렉션과 제네릭  
컬렉션의 개념  
컬렉션 - 요소 라고 불리는 가변 개수의 객체들의 저장소  
-객체들의 컨테이너라고도 불림  
-요소의 개수에 따라 크기 자동 조절  
-요소의 삽입,삭제에 따른 요소의 위치 자동 이동  
고정 크기의 배열을 다루는 어려움 해소  
다양한 객체들의 삽입,삭제,검색 등의 관리 용이  
컬렉션의 특징  
1.컬렉션은 제네릭 기법으로 구현  
1.1제네릭 -   
1.1.1 특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나 메소드를 일반화시키는 기법  
1.1.2 클래스나 인터페이스 이름에 E,K,V 등 타입매개변수 포함  
1.2제네릭 컬렉션 사례 : Vector - E  
1.2.1 E에서 E에 구체적인 타입을 주어 구체적인 타입만 다루는 벡터로 활용  
1.2.2 정수만 다루는 컬렉션 벡터 Vector(Integer)  
1.2.3 문자열만 다루는 컬렉션 벡터 Vector(String)  
2.컬렉션의 요소는 객체만 가능  
2.1 int,char,double 등의 기본타입으로 구체화 불가  
O 제네릭은 형판과 같은 개념  
제네릭 - 클래스나 메소드를 형판엣어 찍어내듯이 생산할 수 있도록 일반화된 형판을 만드는 기법  
JDK 1.5부터 도입(2004 기점) , 모든 종류의 데이터 타입을 다룰 수 있도록 일반화된 타입 매개 변수로 클래스(인터페이스)나 메소드를 작성하는 기법 , C++의 템플릿과 동일  
O 벡터 Vector<.E.>의 특성  
1.<.E.>에 사용할 요소의 특정타입으로 구체화  
2.배열을 가변 크기로 다룰 수 있게 하는 컨테이너  
2.1 배열의 길이 제한 극복  
2.2 요소의 개수가 넘치면 자동으로 길이 조절  
3.요소 객체들을 삽입,삭제,검색하는 컨테이너  
3.1 삽입,삭제에 따라 자동으로 요소의 위치 조정  
4.Vector에 삽입 가능한 것  
4.1 객체,null  
4.2 기본 타입의 값은 Wrapper 객체로 만들어 저장  
5.Vector에 객체 삽입  
5.1 벡터의 맨 뒤, 중간에 객체 삽입 가능  
6.Vector에서 객체 삭제  
6.1 임의의 위치에 있는 객체 삭제 가능  
O 컬렉션과 자동 박싱/언박싱  
JDK 1.5 이전  
1.기본타입 데이터를 Wrapper 객체로 만들어 삽입  
2.컬렉션으로부터 요소를 얻어올 때, Wrapper 클래스로 캐스팅 필요  
JDK 1.5 부터  
1.자동 박싱/언박싱이 작동하여 기본 타입 값 삽입 가능  
O ArrayList <.E>  
가변 크기 배열을 구현한 클래스  
벡터와 거의 동일  
O 컬렉션의 순차 검색을 위한 Iterator  
iterator<.e> 인터페이스  
-리스트 구조의 컬렉션에서 요소의 순차 검색을 위한 인터페이스  
iterator 객체 얻어내기  
-컬렉션의 iterator() 메소드 호출  
-컬렉션 검색 코드  
o HashMap<.K,V>  
키와 값의 쌍으로 구성되는 요소를 다루는 컬렉션  
-K:키로 사용할 요소의 타입  
-V:값으로 사용할 요소의 타입      
-키와 값이 한쌍으로 삽입  
-값을 검색하기 위해서는 반드시 키 이용  
삽입 및 검색이 빠른 특징  
-요소 삽입 : put() 메소드  
-요소 검색 : get() 메소드  
O 제네릭 만들기  
-제네릭 클래스 작성  
1.클래스 이름 옆에 일반화된 타입 매개 변수 추가  
2.제네릭 객체 생성 및 활용  
8단원 자바 GUI 스윙 기초  
o 자바의 GUI  
GUI 응용 프로그램  
GUI
1.사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고, 마우스나 키보드로 입력받을 수 있도록 지원하는 사용자 인터페이스
자바언어에서의 GUI 응용프로그램 작성  
1.AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공  
2.쉬운 GUI 프로그래밍  
AWT와 Swing 패키지  
AWT 패키지  
1.자바가 처음 나왔을 때부터 배포된 GUI패키지, 최근에는 거의 사용하지 않음  
2.AWT 컴포넌트는 중량 컴포넌트(heavy weight component)  
Swing 패키지  
1.AWT기술을 기반으로 작성된 자바 라이브러리  
2.모든 AWT기능 + 추가된 풍부하고 화려한 고급 컴포넌트  
3.AWT 컴포넌트를 모두 스윙으로 재작성,AWT 컴포넌트 이름 앞에 j자를 덧붙임  
4.순수 자바 언어로 구현  
5.스윙 컴포넌트는 경량 컴포넌트  
6.현재 자바의 GUI로 사용됨  
O 컨테이너와 컴포넌트  
컨테이너  
1.다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트  
2.다른 컨테이너에 포함될 수 있음  
컴포넌트  
1.컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체  
2.다른 컴포넌트를 포함할 수 없는 순수 컴포넌트  
3.모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.Component  
4.스윙 컴포넌트가 상속받는 클래스 : javax.swing.JComponent  
최상위 컨테이너  
1.다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너  
O 스윙 GUI 프로그램 만들기  
스윙 GUI 프로그램을 만드는 과정  
1.스윙 프레임 만들기  
2.main() 메소드 작성  
3.스윙 프레임에 스윙 컴포넌트 붙이기  
스윙 프로그램 작성에 필요한 import문  
1.import java.awt.*; //그래픽 처리를 위한 클래스들의 경로명  
2.import java.awt.event.*; //AWT 이벤트 사용을 위한 경로명  
3.import javax.swing.*; //스윙 컴포넌트 클래스들의 경로명  
4.import javax.swing.event.*; //스윙 이벤트를 위한 경로명  
O 스윙 프레임  
스윙 프레임 : 모든 스윙 컴포넌트를 담는 최상위 컨테이너  
1.JFrame을 상속받아 구현  
2.컴포넌트들은 화면에 보이려면 스윙 프레임에 부착되어야 함  
스윙 프레임 기본 구성  
1.프레임 - 스윙 프로그램의 기본 틀  
2.메뉴바 - 메뉴들이 부착되는 공간  
3.컨텐트팬 - GUI 컴포넌트들이 부착되는 공간  
O 프레임 만들기, JFrame 클래스 상속  
스윙 프레임  
1.jframe 클래스를 상속받은 클래스 작성  
2.프레임의 크기 반드시 지정 : setSize()호출  
3.프레임을 화면에 출력하는 코드 반드시 필요 : SetVisible(true) 호출  
O 스윙 응용프로그램에서 main()의 기능과 위치  
스윙 응용프로그램에서 main()의 기능 최소화 바람직  
1.스윙 응용프로그램이 실행되는 시작점으로서의 기능만  
2.스윙 프레임을 생성하는 정도의 코드로 최소화  
O 프레임에 컴포넌트 붙이기  
타이틀 달기  
1.super()나 setTitle() 이용  
컨텐트팬에 컴포넌트 달기  
1.컨텐트팬이란? 스윙 컴포넌트들이 부착되는 공간  
O 스윙 응용프로그램의 종료  
응용프로그램 내에서 스스로 종료하는 방법  
System.exit(0); 1.언제 어디서나 무조건 종료  
프레임의 오른쪽 상단의 종료버튼(X)이 클릭되면 어떤 일이 일어나는가?  
1.프레임 종료, 프레임 윈도우를 닫음 - 프레임이 화면에서 보이지 않게 됨  
2.프레임이 보이지 않게 되지만 응용프로그램이 종료한 것 아님  
2.1 키보드나 마우스 입력을 받지 못함  
2.2 다시 setVisible(true)를 호출하면, 보이게 되고 이전 처럼 작동함  
3.프레임 종료버튼이 클릭될 때,프레임과 함께 프로그램을 종료시키는 방법  
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);



## 4월 19일 강의
5.7 추상 클래스 - 상속에서 추상 클래스는 중요한 슈퍼 클래스의 역할을 한다.  
추상 메소드 - abstract 키워드와 함께 원형만 선언되고, 코드는 작성되지 않은 메소드이다.  
ex) abstract public String getName(); //추상 메소드  
추상 클래스 선언 - abstract로 선언한 클래스로서 두가지 경우가 있다.  
1.추상 메소드를 최소 한 개 이상 가지고 abstract로 선언된 클래스  
2.추상 메소드가 없어도 abstract로 선언한 클래스  
추상 클래스의 인스턴트를 생성할 수 없다.  
응용프로그램에서는 추상 클래스의 인스턴스(객체)를 생성할 수 없다.이는 추상 클래스 실행 코드가 없는 미완성 상태인 추상 메소드가 있을 수 없기 때문이다.  
추상 클래스 상속과 구현  
o추상 클래스의 상속  
추상 메소드를 가진 추상 클래스를 상속받는 서브 클래스는 자동으로 추상 클래스가 된다. 이는 추상 메소드를 상속받기 때문이다.  
ex) abstract class A { //추상 클래스
      abstract public int add(int x, int y); //추상 메소드
      }  
o추상 클래스의 구현 - 서브 클래스에서 슈퍼 클래스의 모든 추상 메소드를 오버라이딩하여 실행 가능한 코드로 구현하는 것을 말한다.  
o추상 클래스의 목적 - 객체(인스턴스)를 생성하기 위함이 아니며, 상속을 위한 슈퍼 클래스로 활용하기 위한 것이다. 추상 클래스는 추상 메소드를 통해 서브 클래스가 구현할 메소드의 원형을 알려주는 인터페이스의 역할을 하고, 서브 클래스의 다형성을 실현한다.  
5.8 인터페이스  
인터페이스는 RS-232 인터페이스, USB 인터페이스, SATA 인터페이스 하드디스크 등 컴퓨터 주변 장치에서 많이 듣던 용어이다. 여기서 인터페이스는 서로 다른 하드웨어 장치들이 상호 데이터를 주고 받을 수 있는 규격을 의미한다.  
O자바 인터페이스란? 인터페이스의 개념은 소프트웨어에서도 적용된다. 소프트웨어를 규격화된 모듈로 만들고, 인터페이스가 맞는 모듈을 조립하듯이 응용프로그램을 작성할 수 있다.  
인터페이스는 객체를 생성할 수 없고, 인터페이스는 다른 인터페이스를 상속할 수 있으며, 인터페이스 구현이란 implements 키워드를 사용한다.  
6.1 패키지  
패키지 - 서로 관련 있는 클래스나 인터페이스의 컴파일된 클래스(.class) 파일들을 하나의 디렉터리에 모아놓은 것.  
모듈 - 여러 개의 패키지들을 모은 것  
모듈화의 목적  
1.java9부터 자바api를 여러 모듈(99개)로 분할  
2.응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축  
모듈의 현실  
1.java9부터 전면적 도입  
2.복잡한 개념  
3.큰 자바 응용프로그램에는 개발 유지보수 등에 적합  
4.현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음  
패키지 사용하기, import문  
자바 소스 코드에서 다른 패키지에 있는 클래스를 사용하고자 한다면, 패키지명을 포함하는 경로명을 사용하여, 컴파일러로 하여금 클래스 파일의 위치를 찾을 수 있도록 해야 한다. 다음은 jdk에서 제공하는 Scanner 클래스를 사용하기 위해,완전 경로명인 java.util.Scanner를 사용한 코드이다.  
6.3 모듈 개념  
모듈 - JAVA9에서 처음 도입된 개념으로, 패키지가 서로 관련 있는 클래스나 인터페이스의 컴파일된 클래스 파일들을 한 곳에 담는 컨테이너라면, 모듈은 패키지들을 담는 컨테이너로 모듈 파일로 저장한다.  
자바 플랫폼의 모듈화  - 모듈 중에서 꼭 필요한 기본 모듈이 JAVA.BASE 모듈이다.  
6.4 자바 jdk에서 제공하는 패키지  
jdk 패키지 계층 구조  - 자바 개발 도구인 JDK는 화면출력,키입력,네트워킹 등 프로그램 개발에 필요한 기본적인 기능과 다양한 응용 기능을 구현한 많은 클래스와 인터페이스들을 포함하는 표준 패키지를 제공하며,이를 자바 API라고 한다.  
jdk의 주요 패키지 - java.lang - System, java.util , java.io , java.awt - GUI , javax.swing  
6.5 object 클래스  
object는 java.lang 패키지에 속한 클래스이며, 모든 클래스는 강제로 object를 상속받는다. object 만이 유일하게 아무 클래스도 상속받지 않는, 자바 클래스 계층 구조의 최상위 클래스이다.  
o객체 속성 object 클래스의 hashcode(), toString() 메소드는 객체의 해시코드 값,객체를 나타내는 문자열 정보를 제공한다.  
o toString() 메소드, 객체를 문자열로 변환 - object에는 객체를 문자열로 변환하는 toString()이 있으며, 각 클래스는 toString()을 오버라이딩하여 자신만의 문자열을 리턴할 수 있다.  
o객체 비교와 equals() 메소드 - 프로그램을 작성하다보면 두 객체가 같은지 비교할 경우가 자주 있다. 기본 타입의 값을 비교하기 위해서는 ==연산자를 사용하지만, 객체 비교를 위해 ==연산자를 사용하면 잘못된 결과를 ㅏㄶ을 수 있다. 객체 비교를 위해서는 equals() 메소드를 사용해야 한다  
6.6 Wrapper 클래스  
개념 - 8개의 기본타입을 객체로 다루기 위해 Byte, short 등의 8개의 클래스를 통칭하여 Wrapper 클래스 라고 말한다.자바는 객체 지향 언어이므로 기본적으로 객체를 대상으로 처리하는 경우가 많다.  
객체 생성 ex) Integer i = Integer.valueOf(10); //정수 10의 객체화  
객체 활용 - 기본 타입 값을 문자열로 변환하거나, 문자열을 기본 타입 값으로 변환하는 메소드들이 주를 이루고 있다.  
박싱과 언박싱 - 기본 타입의 값을 Wrapper 객체로 변환하는 것을 박싱 이라고 하고, 반대의 경우를 언박싱 이라고 한다.  
Integer ten = Integer.valueOf(10); //박싱  
int n = ten.intValue(); //언박싱  
6.7 String과 StringBuffer 클래스  
String 의 생성과 특징 - String 클래스는 문자열을 나타내며, 스트링 리터럴은 String 객체로 처리된다.  
-스트링 리터럴과 new String()  스트링 리터럴과 new String()으로 생성된 스트링은 서로 다르게 관리된다. 스트링 리터럴은 자바 내부에서 리터럴 테이블로 특별히 관리하여, 동일한 리터럴은 공유시킨다.  
-스트링 객체는 수정이 불가능하다.  
o String 활용 - 스트링은 많이 사용되므로 String 클래스의 활용은 중요하다.   
o 공백 제거, trim() - 키보드나 파일로부터 스트링을 입력받을 때, 스트링 앞뒤에 공백이 끼는 경우가 있다.  
StringBuffer 클래스 - 스트링을 다루는 클래스로서, 내부에 가변 크기의 버퍼를 가지고 문자의 개수에 따라 버퍼 크기를 자동 조절한다.  
6.8 StringTokenizer 클래스 - 문자열을 분리하기 위해 사용한다. 문자열을 분리할 때 사용되는 기준 문자를 구분 문자라고 하고 구분 문자로 분리된 문자열을 토큰이라고 한다.  
6.9 math 클래스 - 기본적인 산술 연산을 수행하는 메소드를 제공하는 클래스로서, 모든 메소드가 static 타입이기 때문에 'Math.메소드' 형태로 사용할 수 있다.

## 4월 12일 강의 
4.8-1 static 멤버 사용  
non-static 멤버가 객체 이름으로만 활용할 수 있는 것과는 달리, static 멤버는 객체 이름이나 클래스 이름으로 모두 활용할 수 있다.  
4.8-2 static의 활용  
 -1.전역변수와 전역함수를 만들 때 활용  
응용프로그램 작성 시 모든 클래스에서 공유하는 전역 변수나 모든 클래스에서 호출할 수 있는 전역 함수를 만들고자 할때 static으로 선언하면 된다.  
 -2.공유 멤버를 만들고자 할 때 활용  
static으로 선언된 필드나 메소드는 이 클래스의 객체들 사이에서 공유된다.  
4.8-3 static 메소드의 제약조건  
static 메소드는 2가지 제약조건을 가짐.  
 -1.static 메소드는 오직 static 멤버만 접근할 수 있다.  
static 메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴트 메소드, 인스턴트 변수 등을 사용할 수 없고, static 멤버들만 사용 가능하다. 그러나 인스턴스 메소드는 static 멤버들을 사용할 수 있다.  
 -2.static메소드에서는 this를 사용할 수 없다.  
static 메소드는 객체 없이도 존재하기 때문에, static 메소드에서 this를 사용할 수 없다.  
static 메소드 오류의 예 - static void f() {this.n = x;} // 오류 static 메소드에서는 this 사용 불가능
4.9 final  
final 키워드는 3가지 용도로 사용됨  
 -1.final 클래스  
final이 클래스 이름 앞에 사용되면 클래스를 상속받을 수 없음을 지정한다.  
 -2.final 메소드   
메소드 앞에 final이 붙으면 이 메소드는 더 이상 오버라이딩할 수 없음을 지정한다. 자식클래스가 부모 클래스의 특정 메소드를 오버라이딩하지 못하게 하고 무조건 상속 받아 사용하도록 하고자 한다면 final로 지정하면 된다.  
 -3.final 필드  
자바에서 final 필드를 선언하면 필드는 상수가 된다.  
CHAPTER05 상속  
5.1 상속의 개념  - 객체 지향 언어에서의 상속은 부모유전자를 자식이 물려받는 유전적 상속과 유사하다.  
5.1-1상속의 장점   
 -1.클래스 사이의 멤버 중복 선언 불필요 - 클래스의 간결화  
 -2.클래스들의 계층적 분류로 클래스 관리 용이  
 -3.클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상   
5.2 클래스 상속과 개체  
5.2-1자바의 상속 선언   
자바에서는 extends 키워드를 사용하여 상속을 선언한다. 자바에서는 상속하는 부모 클래스를 슈퍼 클래스, 상속받는 자식 클래스를 서브 클래스 라고 부른다.  
(x,y) 좌표를 가진 한 점을 표현하는 point 클래스와 이를 상속받아 색깔을 추가한 ColorPoint 클래스를 선언하는 예시  
class point {
  int x, y;
} 
class ColorPoint extends point {
  String color;
}  
5.2-2상속과 객체  
 -1.상속 선언 - point를 상속받는 colorpoint의 상속 선언의 예시  
ex) class ColorPoint extends Point { ... }  
 -2.서브클래스 객체 생성 - point클래스의 객체 p와 colorpoint 클래스의 객체 cp는 다음과 같이 생성  
ex) point p = new point();   
    color point cp = new colorpoint();  
상속에서 일차적으로 이해해야 하는 것은 바로 서브 클래스 객체의 모양이다. 객체 p , cp 는 별개의 객체이며 p는 point 클래스의 멤버만 가지고, cp는 point colorpoint 멤버를 모두 가진다.  
 -3.서브클래스 객체 활용  
외부에서 colorpoint 클래스의 public 멤버와 슈퍼클래스 point의 public 멤버를 모두 접근할 수 있다. 그러나 x,,y color는 private 속성이므로 외부에서 접근할 수 없다.  
 -4.서브 클래스에서 슈퍼 클래스 멤버 접근  
서브클래스는 슈퍼클래스의 private 멤버 외 모든 멤버를 접근할 수 있다. x, y는 point의 private 멤버이므로, colorpoint 클래스의 멤버들이 접근할 수 없다. x, y는 오직 set()과 showpoint()만 접근이 허용된다. 
5.2-3 자바 상속의 특징    
 -1.자바에서는 클래스의 다중 상속을 지원하지 않는다. 자바는 C++와 달리 클래스를 여러 개 상속받는 다중 상속(multiple inheritance)을 지원하지 않는다. 다중 클래스 상속은 여러가지 문제점을 가지고 있기 때문이다.  
 -2.자바의 모든 클래스는 자바에서 제공하는 object 클래스를 자동으로 상속받도록 컴파일 된다.  
  
5.3 protected 접근 지정  
자바의 접근 지정자는 private, public, protected, 디폴트 4가지로서 모든 멤버는 이중 하나로 반드시 지정되어야 한다.  
o 슈퍼 클래스의 디폴트 멤버에 대한 서브 클래스의 접근  
접근 지정자가 선언되어 있지 않을 때, 디폴트 접근 지정이라 부르며, 슈퍼 클래스의 디폴트 멤버는 동일한 패키지에 있는 클래스들에게만 접근이 허용된다. 만일 서브 클래스가 슈퍼 클래스와 다른 패키지에 있다면, 슈퍼 클래스의 디폴트 멤버를 접근할 수 없다.  
o protected 멤버  
슈퍼 클래스의 protected 멤버는 다음 두 가지 경우에 접근이 허용된다  
 -1.같은 패키지에 속한 모든 클래스  
 -2.상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)  
5.4 상속과 생성자  
o 서브 클래스와 슈퍼 클래스의 생성자 호출 및 실행  
서브 클래스와 슈퍼 클래스 모두 생성자를 가지고 있다.   
o 서브 클래스에서 슈퍼 클래스 생성자 선택  
 -1.슈퍼 클래스의 기본 생성자가 묵시적으로 선택  
개발자의 명시적 지시가 없으면, 서브 클래스의 생성자가 기본 생성자이든 매개 변수를 가진 것이든, 슈퍼 클래스의 생성자로 기본 생성자가 선택된다.이 선택은 자바 컴파일러에 의해 묵시적으로 이루어진다.  
 -2.super()를 이용하여 명시적으로 슈퍼 클래스의 생성자 선택  
서브 클래스의 생성자에서 슈퍼 클래스의 생성자를 명시적으로 선택하는 것이 원칙이다. super()를 이용하면, 서브 클래스의 생성자에서 슈퍼 클래스 생성자를 명시적으로 선택할 수 있다. super()는 슈퍼클래스의 생성자의 호출을 의미한다.  
5.5 업캐스팅과 instanceof 연산자  
업캐스팅 - 서브클래스 객체가 슈퍼 클래스 타입으려 변환되는 것  
업캐스팅 코드 사례 - person p;  
                    Student s = new Student();  
                    p = s;   슈퍼 클래스의 레퍼런스p가 서브클래스 객체를 가리키도록 치환하는 것이 업캐스팅이다.  
다운캐스팅 - 업캐스팅된 것을 다시 원래대로 되돌리는 것을 다운캐스팅 이라고 한다.  
ex ) Person p = new student("이재문"); // 업캐스팅 Student s = (Student)p; // 다운캐스팅, (student)의 타입 변환을 반드시 지정  
instanceof 연산자와 객체 구별  
업캐스팅을 한 경우 레퍼런스가 가리키는 객체의 진짜 클래스 타입을 구분하기 어렵다.  
instanceof 연산자 사용  
레퍼런스가 가리키는 객체가 어떤 클래스 타입인지 구분하기 위해, 자바에서는 instanceof연산자를 두고 있다.   
5.6 메소드 오버라이딩  
메소드 오버라이딩은 서브 클래스에서 슈퍼 클래스에 선언된 메소드를 중복 작성하여 슈퍼 클래스에 작성된 메소드를 무력화시키고, 객채의 주인 노릇을 하는 것이다.  
-- 오버라이딩의 목적, 다형성 실현  
오버라이딩은 상속을 통해 '하나의 인터페이스(같은 이름)에 서로 다른 내용 구현' 이라는 객체 지향의 다향성을 실현하는 도구이다.  
동적 바인딩 - 실행할 메소드를 컴파일 시에 결정하지 않고 실행 시에 결정하는 것을 말한다. 자바에서는 동적 바인딩을 통해 오버라이딩 된 메소드가 항상 실행되도록 보장한다.  
ex ) SuperObject a = new SuperObject();
     a.paint(); // paint()는 SuperObject의 draw()를 호출한다.  
오버라이딩과 super 키워드  
클래스에서 super 키워드를 이용하면 정적 바인딩을 통해 슈퍼클래스의 멤버에 접근할 수 있다.  
오버로딩과 오버라이딩  
오버라이딩은 슈퍼 클래스에 있는 메소드와 이름, 매개 변수 타입과 개수, 리턴 타입 등이 모두 동일한 메소드가 서브 클래스에 재정의되었을 경우이며, 오버로딩은 한 클래스나 상속 관계에 있는 클래스에 서로 매개 변수의 타입이나 개수가 다른 여러개의 메소드가 같은 이름으로 작성되는 것을 지칭한다.  
5.7 추상 클래스  
추상 메소드 - abstract 키워드와 함께 원형만 선언되고, 코드는 작성되지 않은 메소드이다.  

## 4월 5일 강의
3.4 다차원 배열  
O 다차원 배열 - 자바에서는 여러 차원의 배열을 만들 수 있으며, 일반적으로 3차원 이상의 배열은 잘 사용하지 않기 때문에 이 책에서는 2차원 배열만 다룬다.
  -- 2차원 배열 : 2차원 배열의 선언과 생성  
2차원 배열 래퍼런스 변수 선언 : int intArray[][]; 또는 intArray;  
2행 5열의 2차원 배열 생성 : intArray = new int[2][5]; -> 첫번째 []는 행의 개수, 두 번째 []는 열의 개수를 나타냄  
열 선언과 생성을 동시에 하는 법 : int intArray[][] = new int[2][5];  
2차원 배열의 초기화 : 2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다.  
        int intArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} }; // 3x3 배열 생성
          chat chatArray[][] = { {'a','b','c'}, {'d','e','f'} }; //2x3 배열 생성
          double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} }; //2x2 배열 생성   
  3.5 메소드의 배열 리턴   
  O 메소드의 배열 리턴 - 메소드가 배열을 리턴하는 경우, 배열 메모리 전체가 아닌 배열에 대한 리퍼런스만 리턴됨.    
makeArray()로부터 배열을 리턴받는 경우 - int[] intArray; // makeArray()의 리턴타입과 동일한 타입선언 intArray = makeArray(); // 메소드가 리턴하는 배열 받음  
  3.6 자바의 예외 처리  
  O 자바 예외 처리, 예외란? 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생을 예외(exception)라고 한다. 사용자의 잘못된 입력이나 배열의 인덱스가 배열의 크기를 넘어가는 등의 사건에 의해 프로그램 실행 중에 발생한다.     
예외 발생 경우 3가지 - 1.정수를 0으로 나누는 경우 ,   2.배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우   3.정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

4.1 객체 지향과 자바  
O 자바의 객체지향 특성
  --캡슐화 - 객체률 캡슐로 싸서 내부를 볼 수 없게 하는 것  
객체의 가장 본질적인 특징 - 외부의 접근으로부터 객체 보호 ,   자바의 캡슐화 - 클래스:객체 모양을 선언한 툴   객체:생성한 실체  
--자바 상속 - 상의 클래스의 멤버를 하위 클래스가 물려받음   
                        - 상위 클래스 : 수퍼 클래스  
                         - 하위 클래스 : 서브 클래스  
  --다형성 - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것.
          슈퍼 클래스에 구현된 메소드를, 서브 클래스에서 자신의 특징에 맞게 동일한 이름으로 다시 구현하는 이른바 메소드 오버라이딩(overriding)으로 부른다. 다형성의 또 다른 사례는 클래스 내에서 같은 이름의 메소드를 여러 개 만드는 메소드 오버로딩(overloading)이 있다.    
O 객체 지향 언어의 목적  
--소프트웨어의 생산성 향상  
--실세계에 대한 쉬운 모델링  
O 절차 지향 프로그래밍과 객체 지향 프로그래밍     
 -C언어처럼 실행하고자 하는 절차를 정하고, 이 절차대로 프로그래밍하는 방법을 절차지향 프로그래밍이라고 부른다. 절차 지향 프로그래밍은 목적을 달성하기 위한 일의 흐름에 중점을 둠.  
  -절차지향언어로는 실세계의 문제를 프로그래밍하기에는 표현에 한계가 있다. 객체지향 프로그래밍은 이러한 단점을 극복하고 실세상의 물체를 객체로 표현하고, 이들 사이의 관계,상호 작용을 프로그램을 나타낸다.    
O 클래스와 객체   
   자바를 비롯한 객체지향언어에서 클래스는 객체를 만들어 내기 위한 설계 혹은 틀이며, 클래스에 선언된 모양 그대로 생성된 실체가 객체이다. 이러한 연유로 객체를 클래스의 인스턴스(instance)라고도 부르며, 가끔 객체와 인스턴스는 구별 없이 사용한다.  
4.2 자바 클래스 만들기  
O 자바 클래스 구성 - 자바에서 class 키워드로 클래스를 선언한다. 클래스는 c언어의 구조체와 같이 개발자가 정의하는 새로운 데이터 타입이다. 클래스의 구성요소를 멤버라고 부르며 멤버는 필드(멤버변수)와 메소드(멤버 함수)의 두가지 이다.    
 -클래스 구성 : 클래스는 class키워드와 클래스 이름으로 선언하고 중괄호({})안에 클래스의 필드와 메소드를 모두 작성해야 한다. 클래스 외부에 필드나 메소드를 결코 둘 수 없다.  
 -클래스 멤버 : 클래스의 멤버는 필드와 메소드로서, 필드는 객체의 상태 값을 저장할 멤버 변수이며, 메소드는 실행 가능한 함수이고 객체의 행위를 구현한다. getArea()메소드는 원 내부의 반지름 정보를 이용하여 면적을 계산하여 알려준다.    
 -접근 지정자 : 클래스의 선언부 앞에 붙여진 public은 접근지정자로서, circle 클래스를 다른 클래스에서 이용할 수 있음을 지정한다. 멤버를 public으로 선언하면 다른 클래스에서 마음대로 호출하거나 접근할 수 있도록 공개한다는 뜻이다.    
 O 객체 생성과 활용    
  객체를 생성하는과정은 객체에 대한 래퍼런스 변수 선언과 객체 생성의 두 과정으로 구분된다.    
  1. 래퍼런스 변수 선언 - 객체를 생성하기 전 객체를 가리킬 래퍼런스 변수의 선언이 필요함.     
  ex) Circle pizza; //래퍼런스 변수 pizza 선언  
  2. new 연산자로 객체 생성 ex)pizza = new Circle(); //Circle 객체 생성  
  Circle pizza = new Circle(); // 래퍼런스 변수 pizza의 선언과 동시에 객체 생성  
  3. 객체 멤버 접근 ex) 객체레퍼런스.멤버  
4.3 생성자  
O 생성자의 개념과 목적 - 생성자는 객체가 생성될 때 초기화를 위해 실행되는 메소드이다.    
  생성자의 특징 - 1. 생성자의 이름은 클래스 이름과 동일하다.    
                 2. 생성자를 여러개 작성할 수 있다.   
                 ex) public class Circle {
                        public Circle() {...} //매개변수 없는 생성자
                        public Circle(int r, String n) {...} //2개의 매개 변수를 가진 생성자
                 }  
                 3. 생성자는 객체를 생성할 때 한번만 호출된다.  
                 ex) Circle pizza = new Circle(10, "자바피자"); //생성자 Circle(int r,String n)호출
                     Circle dount = new Circle();  
                 4. 생성자에 리턴 타입을 지정할 수 없다.   ex) public Circle() {...}  
                 ex) public void Circle() {...} // void를 리턴 타입으로 사용할 수 없음.  
                 5. 생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.        
O 기본 생성자 - 매개변수가 없고 또한 실행 코드가 없어 아무일도 하지 않고 단순 리턴하는 생성자이다. 디폴트 생성자라고도 부른다.   ex) class Circle {
                                public Circle() { }
                              }   
 --기본 생성자가 자동으로 생성되는 경우 - 생성자가 없는 클래스는 있을 수 없으며, 클래스에 생성자가 하나도 선언되어 있지 않은 경우, 컴파일러는 기본 생성자를 자동으로 생성한다.     
 --기본 생성자가 자동으로 생성되지 않은 경우 - 생성자가 하나라도 존재하는 클래스에는 컴파일러가 기본 생성자를 임의로 삽입해 주지 않는다.   ex) Circle pizza = new Circle(10); // Circle(int r) 호출   
 O this 래퍼런스 - 객체 자신에 대한 래퍼런스로서 메소드 안에서 사용됨. 컴파일러에 의해 자동 관리되므로 개발자는 사용하기만 하면 된다.  
 O this()로 다른 생성자 호출 - 클래스 내에서 생성자가 다른 생성자를 호출할 때 사용하는 자바코드이다.  
 4.4 객체 배열  
 O 객체 배열 - 자바에서 객체를 원소로 하는 배열을 만들 수 있다. C/C++의 객체 배열과 달리 자바의 객체 배열은 객체에 대한 래퍼런스를 원소로 갖는 배열이며 만드는 방법 또한 다르다.  
 O 배열 선언 및 생성 - 객체 배열을 만들기 위해서는 3단계가 필요함  
        1. 배열에 대한 래퍼런스 선언  
        2. 래퍼런스 배열 생성  
        3. 객체 생성  
O 배열의 원소 객체 접근 - 배열 c의 i번째 객체를 접근하기 위해서는 c[i] 래퍼런스를 사용한다.  
4.5 메소드 활용과 객체 치환  
O 메소드 형식 - 자바의 메소드는 클래스의 멤버 함수로서 접근 지정자를 선언한다는 점 외에 C/C++ 함수의 작성법과 동일하다.  
 o 접근 지정자 - 자바에서 메소드는 반드시 접근 지정자와 함께 선언되어야 한다. 접근 지정자는 'public','private','protected'가 있으며, 접근 지정자가 생략된 '디폴트 접근 지정'의 경우 동일한 패키지 내의 모든 클래스에서 호출 가능하다.  
 o 리턴 타입 - 메소드가 호출자에게 리턴할 값의 타입이다.getSum()은 int 타입의 sum을 리턴하기 때문에 리턴 타입을 int로 선언하였다. 메소드가 아무 값도 리턴하지 않는다면 void 타입으로 선언한다.  
O 인자 전달 - 자바의 메소드 호출 시 인자 전달 방식은 '값에 의한 호출'이다. 호출하는 실인자의 값이 복사되어 메소드의 매개 변수에 전달된다.  
 o 기본 타입의 값이 전달되는 경우 - 매개 변수가 byte, char, int, double 등 기본 타입으로 선언되는 경우, 호출자가 건네는 값이 메소드의 매개 변수에 복사되어 전달한다.  
 o 객체가 전달되는 경우 - 메소드의 매개변수가 클래스 타입인 경우, 객체가 아니라 객체의 래퍼런스 값이 전달된다.  
 o 배열이 전달되는 경우 - 객체가 전달되는 경우와 동일하게. 배열이 통째로 전달되는 것이 아니라 배열에 대한 래퍼런스만 전달된다.  
O 메소드 오버로딩 - 자바 클래스 내에 이름이 같지만 매개 변수의 타입이나 개수가 서로 다른 여러 개의 메소드를 작성할 수 있다. 이것을 "메소드 오버로딩 혹은 메소드 중복" 이라고 부른다. 메소드 오버로딩은 다형성 의 한 종류이다.    
 - 메소드 오버로딩 성립을 위한 두 가지 조건 :   1. 메소드 이름 동일   2.메소드 매개 변수의 개수나 타입이 서로 달라야 함.  
O 객체 치환 시 주의할 점 - 객체를 복사하는 것이 아님.    
4.6 객체의 소멸과 가비지 컬렉션  
O 객체의 소멸 - new에 의해 할당받은 객체와 배열 메모리를 자바 가상 기계뢰 되돌려 주는 행위 , 소멸된 객체 공간은 가용 메모리에 포함  
O 자바에서 사용자 임의로 객체 소멸 안됨 : 자바는 객체 소멸 연산자가 없음   
O 객체 소멸은 자바 가상 기계의 고유한 역할  
O 자바 개발자에게는 매우 다행스러운 기능    
O 가비지 - 할당받은 객체나 배열 메모리 중에서 더 이상 사용하지 않게 된 메모리를 가비지 라고 부른다. 자바 플랫폼은 참조하는 래퍼런스가 하나도 없는 객체나 배열을 가비지로 판단한다  
O 가비지 컬렉션 - 가용 메모리 공간이 일정 크기 이하로 줄어들면, 자바 가상 기계는 자동으로 가비지를 회수하여 가용 메모리 공간을 늘린다.  
ex) System 또는 Runtime 객체의 gc() 메소드를 호출하여, 자바 플랫폼에 가비지 컬렉션을 요청할 수 있다.  
4.7 접근 지정자  
O 자바 패키지 개념   
 -- 패키지 : 상호 관련 있는 클래스 파일을 저장하여 관리하는 디렉터리 , 자바는 하나 이상의 패키지로 구성  
O 접근 지정자 - 대부분 객체지향언어에는 접근지정자를 두고 있다. 클래스나 멤버들을 다른 클래스에 접근해도 되는지의 여부를 선언하는 지시어이다.  
ex)자바의 4가지접근지정자 : private,protected,public  
O 클래스 접근 지정 - 클래스를 작성할 때 다른 클래스가 사용해도 되는지 허용 여부를 지정해야함.  
 o public 클래스 - 클래스 이름 앞에 public으로 선언된 클래스로써, 패키지에 상관없이 다른 어떤 클래스에게도 사용이 허용됨.  
 o 디폴트 클래스 - 접근 지정자 없이 클래스를 선언한 경우, 디폴트는 접근지정으로 선언되었다고한다.  
O 멤버 접근 지정 - 멤버에 대한 공개의 범위 private < 디폴트 < protected < public  
 o public 멤버 - public 선언된 것으로, 패키지를 막론하고 모든 클래스들이 접근 가능  
 o private 멤버 - 비공개를 의미하는 것으로 클래스 내의 멤버들에게만 접근이 허용된다.  
 o protected 멤버 - 보호된 공개를 의미, 두가지 클래스에만 공개한다. 첫째, 같은 패키지 내의 모든 클래스에서 접근이 가능하다. 둘째, 다른 패키지에 있더라도 자식 클래스의 경우 접근이 허용된다.  
 o 디폴트 멤버 - 접근지정자가 생략된 멤버의 경우,디폴트 멤버라고 한다. 동일한 패키지 내에 있는 클래스들만 디폴트 멤버를 자유롭게 접근할 수 있다.  
 4.8 static 멤버  
 O static 멤버 선언 - 클래스의 멤버들 중 다음과 같이 static 지시어로 선언된 멤버를 static 멤버 라고 부른다.  
  o static 멤버의 특성 - 클래스가 하나만 생성되는 멤버, 동일한 클래스의 모든 객체들이 공유하므로 클래스 멤버라고 부른다. 반면 non-static멤버는 각 객체마다 별도로 생기므로 인스턴스 멤버라고 부른다.                 



## 3월 29일 강의
타입 변환 - 변수나 상수 혹은 리터럴을 다른 타입으로 변환하는 것을 말한다.  
O 자동 타입 변환  - 치환문(=)이나 수식 내에서 타입이 일치하지 않을 때, 컴파일러는 작은 타입을 큰 타입으로 자동 변환한다.  
O 강제 타입 변환  - 캐스팅(casting)이라고 부름.  
강제 타입 변환의 에시 int n = 300; byte b = n;(X) byte b = (byte)n; (o)  

자바의 키 입력
O System.in - 표준 입력 스트림 객체,키 값을 바이트 정보로 바꾸어 제공하는 저수준 스트림 객체  
O Scanner를 이용한 키 입력  
o scanner 객체 생성 - Scanner scanner = new Scanner(System.in);
O import문 필요 - scanner를 사용하기 위해서는 프로그램의 맨 앞줄에 import문이 필요함  
예시 - import java.util.Scanner;  
O Scanner 스트림 닫기 - scanner.close();
  
연산자 - 주어진 식을 계산하여 결과를 얻어내는 과정을 연산이라고 한다.  
O 산술 연산 - 더하기,빼기,곱하기,나누기,나머지 5개이며 /는 몫을 구하며 %는 나머지를 구한다.  
O 증감 연산 - ++,-- 두 가지이며, 피연산자의 앞 또는 뒤에 붙어 값을 1 증가시키거나 1 감소시킨다.  
O 대입 연산 - 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입한다.  
대입 연산의 예 int a = 1,b = 3;  a = b; a += b;  a=6 , b는 3 그대로  
O 비교연산 - 두 개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자  
O 조건연산 - 세 개의 피연산자로 구성되어 삼항(ternary) 연산자 라고 불리며 condition ? opr2 : opr3 
condition이 true 이면 opr2의 값이, false 이면 opr3의 값이 된다.  
O 비트 연산,시프트 연산 - 비트연산은 비트끼리 AND, OR, XOR, NOT 연산을 하는 비트논리연산, 비트를 오른쪽 왼쪽으로 이동시키는 비트 시프트 연산이 있다.  
시프트 연산 역시 각 비트들을 대상으로 연산이 이루어지며 3개의 연산자가 있으며 float, double, boolean데이터는 시프트 연산을 할 수 없다.

조건문   
O 단순 IF문 - 조건식은 비교연산이나 논리 연산의 혼합된 식으로 구성되며 결과는 불린 값이다. 조건식이 참이면 IF 내부의 실행 문장이 실행되며ㅡ 거짓이면 IF문을 벗어난다.  
O if-else 문 - if의 조건식이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다. 조건식이 true이면 실행문장 1을 행한 후 if-else문을 벗어나고, false이면 실행문장 2를 실행한 후 if-else문을 벗어난다.  
(다중 if-else문은 if-else가 연속되는 것이다.)  
O 중첩 if-else문 - if문이나 if-else문, 혹은 else문의 '실행 문장'에 if문이나 if-else문을 내포할 수 있다.   
O switch 문 - 값에 따라 여러 방향으로 분기하는 경우, if 문보다 switch 문을 사용하면 가독성이 높은 좋은 코드를 작성할 수 있다. 

반복문
O for 문 - 작업문은 for문이 반복되는 동안 매번 실행되며, 작업문이 하나의 문장인 경우 중괄호({})가 필요 없다. 초기문에서는 대개 for문의 조건식에서 사용하는 변수를 초기화한다. 조건식에는 논리 변수나 논리 연산을 사용하며, 조건식의 결과가 true인 경우에 반복이 계속되고 false가 되면 for문을 벗어난다.  
O while 문 - 조건식은 for문과 동일하다. true인 경우 반복이 게속되며, false인 경우 while문을 벗어난다. for문과 달리 조건식이 없으면 컴파일 오류가 발생한다.  
O do-while 문 - 조건식은 while문과 동일하며, 조건식이 없으면 컴파일 오류가 발생. 다른 반복문과 달리 작업문 실행 후 반복 조건을 따지므로 작업문이 최초 한번은 반드시 실행된다.  
O 중첩 반복 - 반복문 안에 다른 반복문을 만들 수 있다. for문 안에 for문 이나 while 문을 만들 수도 있고,while 문 안에 for,while,do - while 문을 둘 수 있다.
O continue 문과 break 문 - 반복문과 함께 사용되면서 반복의 흐름을 바꾸거나, 반복에서 벗어나게 하는 중요한 기능을 한다. continue 문은 반복문을 빠져나가지 않으면서 즉시 다음 반복으로 넘어가고자할 때 사용됨 break문은 하나의 반복문을 즉시 벗어날 때 사용함.

배열  - 인덱스와 인덱스에 대응하는 일련의 데이터들로 이루어진 연속적인 자료구조로서, 배열에는 같은 종류의 데이터들이 순차적으로 저장된다. 10개의 정수 값을 합할 때, 10개의 변수를 사용한 경우와 자바 배열을 사용한 경우를 대조하여 보여준다.  
배열 선언 및 생성 - 자바에서 배열을 생성하는 방법은 C/C++와 달리 래퍼런스 변수 선언과 배열 생성의 단계가 필요하며, 5개의 정수 배열을 만드는 과정을 보여줌.   
배열 선언문 - int intArray[];  
O 배열 생성 - 배열 공간을 할당받는 과정. 반드시 new연산자를 이용하여 배열을 생성하며 []안에 생성할 원소 개수를 지정한다. int intArray = new int[5]; 다음과 같이 배열 선언과 생성을 동시에 할 수도 있다.  
O 배열 초기화 - '{}' 사이에 원소를 나열하여 초기화된 배열을 만들 수 있다.
O 배열 인덱스와 배열 원소 접근 - 배열의 인덱스는 정수만 가능하며, 인덱스는 0부터 시작하고 마지막 원소의 인덱스는 [배열 크기-1] 이다. 
O 래퍼런스 치환과 배열 공유 - 배열 공간과 레퍼런스 변수가 분리되어 있기 때문에 생성된 배열에 대한 공유가 쉽게 이루어진다. 즉 생성된 배열을 다수의 래퍼런스가 참조 할 수 있다.  
O 배열의 크기, length필드 - 자바는 배열을 객체로 다룬다. 배열이 생성되면 배열 공간과 함께 배열의 크기 값을 가진 length필드가 배열 객체 내에 생성된다. length 필드를 이용하면 프로그램에서 배열의 크기를 따로 관리할 필요가 없다.  
O 배열과 for-each문 - for 문을 변형한 for-each문은 배열이나 나열의 크기만큼 루프를 돌면서, 각 원소를 순차적으로 접근하는데 매우 유용하다.



## 3월 22일 강의
자바 프로젝트 및 클래스 생성 하는 방법 그리고 소스 편집 컴파일 및 실행 하는 방법을 배웠다.  

자바 응용프로그램의 종류 - 데스크톱 응용프로그램,자바 서블릿 응용프로그램 등이 있으며 모바일 응용프로그램이 있다  

자바의 특징 - 플랫폼 독립성 , 객체지향 , 클래스로 캡슐화 , 소스와 클래스 파일 , 실행코드배포 , 패키지 , 멀티스레드 등등이 있다.  

자바프로그램의 구조 - 클래스, 주석문, 메소드, main()메소드, 메소드호출, 변수, 화면출력 으로 구성되어 있다.  

식별자 - 클래스, 변수, 상수, 메소드에 붙이는 이름을 말한다.  
        식별자로 한글을 사용할 수 있으며, 첫번째 문자는 숫자를 사용할 수 없고 대소문자를 구별한다.  


## 3월 15일 강의
10:00 ~ 11:50 깃 허브 주소를 복사하여 vscode에 붙여넣기 하고 깃허브를 활용하는 방법을 배웠다.
              SOURCE CONTROL 에서 내용을 넣고 commit을 누르고 업로드를 하면 나의 깃허브 주소에 내가 
              vs code에서 작성한 내용이 올라가게 되는 방식이다.

12:00 ~ 12:50 java 개발 환경 구축   
              openJDK 설치 - 설치가 오래 걸려 설치 하다가 끝남
              Eclips 설치 - 설치하였으나 교수님께서는 VSCODE를 사용하여 수업을 진행하심.  
              Eclips에 openJDK 연결 - Eclips와 JDK를 연결하여 eclips를 통해 테스트 완료  
              자바 프로젝트 생성 - 자바에서 텍스트를 출력하는 방법을 간단하게 배웠다.

